[[nginx-ingress]]
= NGINX Ingress Controller

The basics of Kubernetes ingress exposes HTTP and HTTPS routes from the outside of a cluster to services created inside the cluster. An Ingress controller with an ingress controller service is responsible for supporting the Kubernetes ingress. In order to use Kubernetes ingress, you need to install the ingress controller with the ingress controller service to be exposed to the outside of the cluster. Traffic routing is controlled by rules defined on the Ingress resource from backend services.

=== Configure and deploy NGINX ingress controller


. Choose which networking configuration the ingress controller should have.
Create a file [path] _nginx-ingress-config-values.yaml_ with one of the following examples as content.

* **NodePort**: The services will be publicly exposed on each node of the cluster, including master nodes, at port `32443` for `HTTPS`.
+
----
# Enable the creation of pod security policy
podSecurityPolicy:
  enabled: false

# Create a specific service account
serviceAccount:
  create: true
  name: nginx-ingress

# Publish services on port HTTPS/32443
# These services are exposed on each node
controller:
  service:
    enableHttp: false
    type: NodePort
    nodePorts:
      https: 32443
----
+
* **External IPs**: The services will be exposed on specific nodes of the cluster, at port `443` for `HTTPS`.
+
----
# Enable the creation of pod security policy
podSecurityPolicy:
  enabled: false

# Create a specific service account
serviceAccount:
  create: true
  name: nginx-ingress

# These services are exposed on the node with IP 10.86.4.158
controller:
  service:
    enableHttp: false
    externalIPs:
      - 10.86.4.158
----
+
* **LoadBalancer**: The services will be exposed on the loadbalancer that the cloud provider serves.
+
----
# Enable the creation of pod security policy
podSecurityPolicy:
  enabled: false

# Create a specific service account
serviceAccount:
  create: true
  name: nginx-ingress

# These services are exposed on IP from a cluster cloud provider
controller:
  service:
    enableHttp: false
    type: LoadBalancer
----

. Deploy the ingress controller from the helm chart link:https://kubernetes-charts.suse.com/[$suse charts repository]
and pass along our configuration values file by running `helm repo add suse https://kubernetes-charts.suse.com`.
+
TIP: For complete instructions on how to install Helm and Tiller refer to <<helm_tiller_install>>.
+
[source,bash]
----
kubectl create namespace nginx-ingress

helm install --name nginx-ingress suse/nginx-ingress \
--namespace nginx-ingress \
--values nginx-ingress-config-values.yaml
----
+
The result should be two running pods:
+
[source,bash]
----
kubectl -n nginx-ingress get pod
NAME                                             READY     STATUS    RESTARTS   AGE
nginx-ingress-controller-74cffccfc-p8xbb         1/1       Running   0          4s
nginx-ingress-default-backend-6b9b546dc8-mfkjk   1/1       Running   0          4s
----
+
The result should be two services:
+
* NodePort
+
[source,bash]
----
kubectl get svc -n nginx-ingress
NAME                            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE
nginx-ingress-controller        NodePort    10.100.108.7     <none>        443:32443/TCP   2d1h
nginx-ingress-default-backend   ClusterIP   10.109.118.128   <none>        80/TCP          2d1h
----
+
* External IPs
+
[source,bash]
----
kubectl get svc -n nginx-ingress
NAME                            TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)         AGE
nginx-ingress-controller        LoadBalancer   10.103.103.27  10.86.4.158   443:30275/TCP   12s
nginx-ingress-default-backend   ClusterIP      10.100.48.17   <none>        80/TCP          12s
----
+
* LoadBalancer
+
[source,bash]
----
kubectl get svc -n nginx-ingress
NAME                            TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE
nginx-ingress-controller        LoadBalancer   10.106.160.255   10.86.5.176   443:31868/TCP   3h58m
nginx-ingress-default-backend   ClusterIP      10.111.140.50    <none>        80/TCP          3h58m
----

. Create DNS entries
+
You should configure proper DNS names in any production environment. `k8s-dashboard.com` will be the domain name we will use in the ingress resource.
These values are only for example purposes.
+
* NodePort
+
The services will be publicly exposed on each node of the cluster at port 30443 for HTTPS. In this example, we will use a worker node with IP 10.86.14.58.
+
----
k8s-dashboard.com                      IN  A       10.86.14.58
----
+
Or add this entry to /etc/hosts
+
----
10.86.14.58 k8s-dashboard.com
----
+
* External IPs
+
The services will be exposed on a specific node of the cluster, at the assigned port for HTTPS. In this example, we used the external IP 10.86.4.158.
+
----
k8s-dashboard.com                      IN  A       10.86.4.158
----
+
Or add this entry to /etc/hosts
+
----
10.86.4.158 k8s-dashboard.com
----
* LoadBalancer
+
The services will be exposed on an assigned node of the cluster, at the assigned port for HTTPS. In this example, LoadBalancer provided the external IP 10.86.5.176.
+
----
k8s-dashboard.com                      IN  A       10.86.5.176
----
+
Or add this entry to /etc/hosts
+
----
10.86.5.176 k8s-dashboard.com
----

=== Deploy Kubernetes Dashboard as an example

. Deploy Kubernetes dashboard
+
[source,bash]
----
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc5/aio/deploy/recommended.yaml
----

. Create cluster-admin account to access the Kubernetes dashboard
+
This will show how to create simple admin user using Service Account, grant it the admin permission then use the token to access the kubernetes dashboard.
+
[source,bash]
----
kubectl create serviceaccount dashboard-admin -n kube-system
kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin
----

. Create the TLS secret
+
Please refer to <<trusted_server_certificate>> on how to sign the trusted certificate. In this example, crt and key are generated by a self-signed certificate.
+
[source,bash]
----
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /tmp/dashboard-tls.key -out /tmp/dashboard-tls.crt -subj "/CN=k8s-dashboard.com/O=k8s-dashboard"
kubectl create secret tls dashboard-tls --key /tmp/dashboard-tls.key --cert /tmp/dashboard-tls.crt -n kubernetes-dashboard
----

. Create the ingress resource
+
We will create an ingress to access the backend service using the ingress controller.
Create _dashboard-ingress.yaml_ with the appropriate values
+
----
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: dashboard-ingress
  namespace: kubernetes-dashboard
  annotations:
    kubernetes.io/ingress.class: nginx
    ingress.kubernetes.io/ssl-passthrough: "true"
    nginx.ingress.kubernetes.io/secure-backends: "true"
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  tls:
    - hosts:
      - k8s-dashboard.com
      secretName: dashboard-tls
  rules:
  - host: k8s-dashboard.com
    http:
      paths:
      - path: /
        backend:
          serviceName: kubernetes-dashboard
          servicePort: 443
----

. Deploy dashboard ingress
+
[source,bash]
----
kubectl -f dashboard-ingress.yaml
----
+
The result will look like this.
+
[source,bash]
----
kubectl get ing -n kubernetes-dashboard
NAMESPACE            NAME                 HOSTS               ADDRESS   PORTS     AGE
kubernetes-dashboard dashboard-ingress    k8s-dashboard.com             80, 443   2d
----
+

. Access Kubernetes Dashboard
Kubernetes dashboard will be accessible through ingress domain name with ingress controller port
+
.Access Token
[NOTE]
====
Now weâ€™re ready to get the token from dashboard-admin by following command.
[source,bash]
----
kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk '/dashboard-admin/{print $1}')
----
====
+
* NodePort: https://k8s-dashboard.com:32443
* External IPs: https://k8s-dashboard.com
* LoadBalancer: https://k8s-dashboard.com

