<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<chapter version="5.0" xml:id="deployment.about"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
<title>About &productname;</title>
 </info>
 
 <para>
  &productname; is a platform designed for fast deployment of container-based applications. You can deploy &productname; on you physical machines or you can use it on virtual machines. After you deploy it, it is ready to run out of the box. It provides high scalability of your cluster&mdash;from 10 to 1000 nodes. 
 </para>
 <para>
  &productname; was designed to simplify transformation of applications into container-based applications. Creating clouds with container-based application is much easier as you get rid off problems with compatibility and depenencies. To enable as fast application deployment as possible, it is recommended to use container orchestration framework, e.g. Kubernetes.
 </para>
 <para>
  While &productname; inherits benefits of &sle; uses tools and technologies well-known to system administrators&mdash;like <literal>cloud-init</literal>,  Kubernetes or Salt&mdash;the main inovation (compared to &sls;) comes with <emphasis role="bold">transactional updates</emphasis>. A transactional update is an update that can be installed when the system is running without any down time. The transaction update can be rolled back, so if the upgrade fails or the update is not compatible with your infrastructure, you can restore the previous state. 
 </para>
 <para>
   &productname; uses the BTRFs file system with the following characteristic:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     The base OS and snapshots are read-only.
    </para>
   </listitem>
   <listitem>
    <para>
     Subvolumes for data sharing are read-write.
    </para>
   </listitem>
   <listitem>
    <para>
     &productname; introduces overlays of <literal>/etc</literal> directories used by <literal>cloud-init</literal> and &salt;
    </para>
   </listitem>
  </itemizedlist>
 <sect1 xml:id="caasp.architecture">
  <title>&productname; Architecture</title>
  <para>
   A typical &productname; cluster consists of several types of nodes:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     &admin_node; - is a &smaster; that assigns roles to &sminion;s. The node runs the GUI dashboard that manages the whole cluster.
    </para>
   </listitem>
   <listitem>
    <para>
    &node; - is a &sminion; that can have a following role:
     <itemizedlist>
     <listitem>
    <para>
     Kubernetes master - that manages all containers.
    </para>
   </listitem>
   <listitem>
    <para>
     Kubernetes worker - that runs containers.

    </para>
   </listitem>
     </itemizedlist>
    </para>
   </listitem>   
  </itemizedlist>
  <para>
   In large-scale clusters, there are other nodes that can help you to manage and run the cluster:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     a local &smt; server that manages subscriptions for workers and so decreases the traffic to &scc;
    </para>
   </listitem>
   <listitem>
    <para>
     a log server that stores logs of cluster nodes.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   The following figure illustrates interactions of the nodes.
  </para>
  <figure xml:id="caasp.architecture.cluster">
   <title>&productname; Nodes Architecture</title>
   <mediaobject>
    <imageobject>
     <imagedata fileref="caasp_architecture.svg" format="SVG"/>
    </imageobject>
   </mediaobject>
  </figure>
  <para>
   Now let's focus on a more detail view of the cluster that involves also services running on each node type.
  </para>
  <figure xml:id="caasp.architecture.services">
   <title></title>
  </figure>
  <para>
   Each node is described further.
  </para>

  <sect2 xml:id="administration_dashboard">
   <title>The Administration Node</title>
   <para>
    The &admin_node; is intended to manage deployment of the cluster and runs applications required for a proper function of the cluster. The &admin_node; runs the administration dashboard called &dashboard;, the <emphasis>salt-api</emphasis>, the MariaDB database, the <literal>etcd discovery</literal> server, the <literal>salt-master</literal> and <literal>salt-minion</literal>. The dashboard, database and daemons all run in separate containers.
   </para>
   <para>
   The &salt; daemons are used to manage the cluster nodes and to handle incoming/outgoing communication between nodes, the <literal>salt-minion</literal> is used to generate a required CA certificate. The MariaDB database stores the dashboard data and &salt; events (commands completions, new &sminion;s that require registration, etc.). 
   </para>
   <para>
    The <literal>etcd discovery</literal> is only used to bootstrap other instances of <literal>etcd</literal> and is not part of the <literal>etcd</literal> cluster that runs on the &kmaster; and &kworker;s.
   </para>
   <para>
   The dashboard is a web application that enables you to manage, monitor and deploy the cluster. The dashboard manages the cluster by using the <emphasis>salt-api</emphasis> to interact with the underlying &salt; technology. 
   </para>
   <para>
   The containers on the &admin_node; are managed by <literal>kubelet</literal> as a static pod. Bear in mind that this <literal>kubelet</literal> does not manage the cluster nodes. Each cluster node has its own running instance of <literal>kubelet</literal>.
   </para>
         
   <sect3 xml:id="master.node">
    <title>The Master Node</title>
    <para>
     The &kmaster; runs the services and daemons that handle orchestration of containers running on all &kworker;s. In contrast to the &admin_node;, the services and daemons do not run in containers.
    </para>
   </sect3>
   
   <sect3 xml:id="worker.node">
    <title>The Worker Node</title>
    <para>
     Each &kworker; can run several containers. To run the containers properly, there is an instance of <literal>etcd</literal>,  the container engine and <literal>kubelet</literal> that communicates with the &kmaster;.
    </para>
   </sect3>
  </sect2>    

 </sect1>
 </chapter>
